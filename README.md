# VEHICLE SIGNAL DISTRIBUTION [VSD]
Library to publish and subscribe Vehicle Signal Specification signals
via reliab le multicast.


VSD reads a signal specification CSV file, generated from the GENIVI
Vehicle Signal Specification project, and provides API calls to
set, publish, subscribe, and receive to these signals.

Please see [Vehicle Signal Specification (VSS)](https://github.com/GENIVI/vehicle_signal_specification)
project for details on branches, signal structures and attributes.

A signal\'s value is set and published as two separate operations.

Publishing can be done on an individual signal level, or on a branch
level. If a branch is published, the branch and all its children are
published in an atomic operation. This allows complex signal
structures to be easily transmitted.

Subscriptions can also be done an signal or on a branch level. If a
branch is subscribed to, a callback will be made for any signal that
is updated under that branch.

## Generating Documentation with Doxygen

The Doxyfile for generating documentation is located under **doc** folder.
Generating the docs can be done with the following instructions.

```doxygen doc/Doxygen```

Note this requires the following packages to be install to generate docs

* doygen
* doxypy
* doxyqml

## Using Vehicle Signal Distribution:
Be sure that you have built and deployed libraries for both dstc and
reliable_multicast (RMC), as they are dependencies of the vsd project.

The libraries can be found at:

[Reliable Multicast v1.3](https://github.com/PDXostc/reliable_multicast/releases/tag/v1.3)
[DSTC v1.2](https://github.com/PDXostc/dstc/releases/tag/v1.2)


Build and install RMC first, followed by DSTC, and ensure that
`Makefile` has include and link paths setup to the install
directories.

VSD currently will produce a shared object to link against, and also
compiles two example programs to begin working with the project. Build
and install these using:

    make
    make DESTDIR=/usr/local install

## RUNNING THE EXAMPLE
The programs `vsd_pub_example` and `vsd_sub_examples` are built and
installed, providing an insight into how VSD works.

## Running `vsd_sub_example`
The usage for `vsd_sub_example`, which subscribes to signals sent
by `vsd_pub_example` is shown below.

     ./vsd_sub_example /usr/local/share/vss_rel_2.0.0-alpha+005.csv Vehicle.Drivetrain.InternalCombustionEngine

The first argument, `/usr/local/share/vss_rel_2.0-alpha+005.csv` is a CSV variant of the vehicle signal specifiation
generated by running `make` in a checked out VSS repo. It contains a tree structure of all signals,
their type, allowed values, if they are actuators, sensors, or others, etc. VSD uses this as a
global specification of all signals that can possibly be seen on the network, even if
not all of them are supported in a given deployment.

All VSD nodes must load the same version of the file in order to have the definition of signals.

A sample VSS csv file is installed under the `share` directory of the VSD install directory.

The second argument, `Vehicle.Drivetrain.InternalCombustionEngine`, specifies the subtree that
is to be subscribed to. If any signal in the given subtree is received, a callback will be made
to the subscriber. This allows the subscriber to chose the granularity of the subscription, from
individual signals to the whole vehicle state.

## Running `vsd_pub_example`
The usage for `vsd_pub_example`, which publishes signals to
zero or more `vsd_sub_example` instances network, is shown below.

    vsd_pub_example -d /usr/local/share/vss_rel_2.0.0-alpha+005.csv \
                    -s Vehicle.Drivetrain.InternalCombustionEngine.Engine.Power:230 \
                    -s Vehicle.Drivetrain.InternalCombustionEngine.FuelType:gasoline \
                    -p Vehicle.Drivetrain.InternalCombustionEngine

The `-d /usr/local/share/vss_rel_2.0.0-alpha+005.csv` argument
specifies where to load the signal specification file from. This file
must be the same as that used by `vsd_sub_example`.

The `-s Vehicle.Drivetrain.InternalCombustionEngine.Engine.Power:230`
argument sets the value of the `Power` signal for the engine to `230`.

The `-s Vehicle.Drivetrain.InternalCombustionEngine.FuelTyoe:gasoline`
argument sets the value of the `FuelTyoe` signal for the engine to `gasoline`.

The `-p Vehicle.Drivetrain.InternalCombustionEngine`
argument specifies that all signals under the `InternalCombustionEngine` should be published
atomically.

Atomic signal publishing allows for the transmission of arbitrarily complex signals as a single, cohesive unit.
The callback will receive a list of all the published signals, which represents a snapshot of the published tree
at that exact moment in time.

## API CALL FLOW - PUBLISHER
Below is an outline of how to:

1. Load a VSS signal descriptor file.
2. Locate a signal by a VSS signal path.
3. Set the signal\'s value.
4. Publish the signal.


### Load VSS signal descriptor file

The VSD system is hosted by a context variable that is setup by the library.
In order to initialize VSD, a pointer to a `vsd_context_t` pointer is provided
to `vsd_load_from_file()` together with the VSS file to load.

    vsd_context_t* ctx = 0;
    vsd_load_from_file(&ctx, "vss_2.0.0.csv");

The `vss_2.0.0.csv` file is generated by the VSS project (link in
introduction). Please note that the loaded CSV file needs to have
signal IDs for branches, not only the signals themselves.  To verify
if this is the case, check that the second field in the CSV has a
number (in quotes) for each line.

### Locate a signal by its path
Before a signal can be set, a signal descriptor



    res = vsd_find_desc_by_path(ctx, 0, argv[2], &desc);

    if (res) {
        printf("Cannot find signal %s: %s\n", argv[2], strerror(res));
        exit(255);
    }

    if (vsd_elem_type(desc) == vsd_branch) {
        printf("Cannot signal %s is a branch: %s\n", argv[2], strerror(res));
        exit(255);
    }

    res = vsd_string_to_data(vsd_data_type(desc), argv[3], &val);

MORE
